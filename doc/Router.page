---
title: "Router Class"
subtitle: "A simple, lightweight, code-only front-end Web framework."
projectTitle: CodeOnly
---
# Router Class

CodeOnly includes a simple, but flexible URL router designed for use
in single-page apps.

The router requires the History API and provides normal web-history
style routing (not hash based routing).

## Router Class and Singleton Instance

The `Router` class implements the router functionality;

```js
import { Router } from "@toptensoftware/codeonly"

// Create router
let router = new Router();

// Use router...
```

However since you only ever need one instance, there is a built-in
singleton instance available as `router`.

```js
import { router } from "@toptensoftware/codeonly"

// Use router...
```

## Router Framework

Routing involves the following participants:

* Router instance - the main router instance responsible for navigation and working
  with the browser's History API.
* Route handlers - objects registered with the Router to provide URL
  matching and handling.
* Route instances - an object that represents the currently matched URL and includes
  information like the URL, the associated handler, state and any other data the 
  handler wishes to associate with the route.
* Router listener - listens to navigation events from the Router and updates
  the DOM with the newly navigated to page.


## Registering Route Handlers

Route handlers are registered using the Router's `register` function which expects
an object with properties that control the route handler's behaviour:

```js
router.register({
    // The URL pattern this route handler matches
    pattern: "/about",

    // A handler called if pattern matches
    match: (route) => {

        // Create component for this object
        route.page = new AboutPageComponent();

        // Return true to confirm match of this route
        return true;
    }
});
```

## Registering Navigation Listeners

Once a route has been matched, it's up to your application to do something with
that matched route by listening to the "navigate" event.

```js
router.addEventListener("navigate", () => {

    // Load navigated page into router slot
    if (router.current.page)
        this.routerSlot.content = router.current.page;

});
```


## The Router Object

The `router` class instance supports the following methods and properties:

* `current` - the route object of the currently matched URL
* `navigate` - starts forward navigation to a new page
* `back` - starts backward navigation to the previous page, or if there is
  no previous page to the home page.
* `register` - registers a route handler
* `prefix` - an path prefix if the application is mounted in a sub-path (set this
  before calling the `start` method
* `start` - starts the router, connecting to window and history events and
  performing the initial page navigation for the starting URL.


## The Route Handler

Route handlers are objects you register with the Router.  The following
properties are supported:

* `pattern` - an optional `RegExp` or string specifying a URL pattern for this
  route handler to match against.  If not specified, the `match` function will
  be called for all URLs.

  If the pattern is a string, it's first converted to a RegExp using the `urlPattern` 
  function.

* `match(route)` - a callback that is invoked once the pattern has been matched (or always
  if pattern is not specified).  `route` will be the Route object partially constructed
  and will have the `url`, `originalUrl`, `match` and `state` parameters set.

  The `match` function can reject the match by returning `false`, or accept it by
  returning `true`.  When matching, a route handler will typically assign additional
  information and objects to the route (eg: the page component instance to show).

  If the match function returns `null`, router navigation is canceled and the navigation
  passed back to the browser to do page load navigation.

* `leave(route)` - a callback invoked when navigating away from any route matched
  by this handler.

* `order` - an optional numeric value indicating the order this route handler
  should be matched in comparison to others.  Defaults to `0` if not specified.


## The Route Object

Once a URL is matched to a route handler, a `route` object is created
representing the current route with the following properties:

* `url` - the matched url
* `originalUrl` - the original full URL before the prefix was stripped
* `match` - the result of running the pattern RegExp against the URL
* `handler` - the route handler that matched the URL
* `state` - any previously saved history state

Also, the route handler can attach any additional information to the route
object as required.

In the above examples, note how the `/about` route handler creates an 
`AboutPageComponent` instance and stores it on the route object.  This component
instance is then picked up by the `navigate` listener elsewhere in the app
and loaded into an `EmbedSlot`.


## Not Found Page

To handle URL's not recognized by your app, you should register
a "Not Found" page.

Notice this handler doesn't have a pattern (ie: it matches
anything) and the `order` property is set high enough to be matched
after all other routes have failed to match.

```js
router.register({
    match: (r) => {
        r.page = new NotFoundPage(r.url);
        return true;
    },
    order: 1000,
});
```


## Creating Links to Routes

The router listens for any clicks on `<a ...></a>` tags with a `href` that
starts with a `/` and, if set, matches the `router.prefix`.

All other clicks on links will be ignored by the router and normal
page load navigation will take place.



## Reverting to Browser Navigation

If you have links that look like in-app links but are actually out-of-page 
links, you can force an page load navigation by returning `null` from a route
handler's `match` function.

eg: suppose want `/admin` to leave the single page and instead to page-load 
navigation:

```js
router.register({
    pattern: "/admin"
    match: (r) => null,         // null means cancel router and pass to browser.
});
```



## Typical Setup

The following describes a typical setup for using the router.

Firstly, create a component for each of your pages and register a route handler 
for it:

```js
import { Component, router } from `@toptensoftware/codeonly`

// A component for the product page
class ProductPage extends Component
{
    constructor(product_id)
    {
    }
    // etc...
}

// Register route handler
router.register({
    pattern: "/product/:productId",
    match: (route) => {

        // Create new product page
        route.page = new ProductPage(route.groups.productId);

        // Indicate we've matched this route
        return true;

    },
});

```

Next, listen for the "navigate" event and load the created page into
the main content area of your app.

Also, call the router's `start` method to hook up event handlers and
do the initial page navigation.

```js
import { Component, router } from `@toptensoftware/codeonly`

// Main application instance mounted to DOM
class Application extends Component
{
    constructor()
    {
        // Listen for navigate event
        router.addEventListener("navigate", () => {

            // Load navigated page into router embed slot
            this.routerSlot.content = router.current.page;

        });

        // Start the router (connect to window and history 
        // navigation events, do initial page navigation).
        router.start();
    }


    static template = {
        type: "main",
        $: [
            { 
                // Router pages will be loaded here
                type: "embed-slot", 
                bind: "routerSlot",
            },
        ]
    };
}

```

That's it for simple page navigation.


## Routes to Modal Dialogs

In additional to regular page navigation, the router can also be used
for routes that present as modal dialogs.

Firstly, the match function should create and show the modal dialog:

```js
router.register({
    pattern: "/product-photo-popup/:productIdd",
    match: (r) => {
        r.modal = new ProductPhotoDialog(r.match.groups.productId);
        r.modal.showModal();
        return true;
    },
    leave: (r) => {
        r.modal.close();
    },
});
```

Notice how the `match` function doesn't set the `page` property on the
route and the Application shouldn't try to load the page in this case.  

(This is why the "navigate" event listener above checks if the route's 
`page` property is set before loading it into the router slot).

As is, this will handle forward and back navigation to/from the dialog
however we need to also handle the case where the user explicitly closes
the dialog via a button or Escape key.

Your dialog probably already has a `close` listener to remove the 
dialog from the DOM when it's closed. At this point, we just check
if the current route refers to this dialog, and if so, tell the 
router to navigate back:

```js
    this.dom.rootNode.addEventListener("close", () => {

        // If we're the current router item this means
        // we were closed by the UI (escape key) and not
        // by navigating backwards.  Do the back navigation
        // now to go back to where we came.
        if (router.current.modal == this)
            router.back();
```

Note: if the initial page loaded by the app was the dialog, the `back`
function doesn't have anywhere to go back to.  The router detects this
case and instead navigates to the home page - as indicated by the 
`router.prefix` if set, otherwise `/`.

